
# A strategy for successfully building applications using Hibernate and jOOQ

Building performant and maintainable applications using [Hibernate ORM](https://hibernate.org/orm/)
can be hard. At least that has been my experience for a long time. To be honest, I did not understand
Hibernate sufficiently well, and neither did many of my co-workers.

Moreover, I considered Hibernate as being more or less synonymous with the first-level cache, not realizing
that *JPQL* (as an "object-oriented SQL dialect") might be more fundamental. I also had no idea that
Hibernate offers a `StatelessSession` (without first-level cache) as alternative to `Session`
(which extends JPA interface `EntityManager`).

At some point, with the help of resources such as
[A Short Guide to Hibernate](https://docs.hibernate.org/orm/7.1/introduction/html_single/) and lots
of experimentation I started to "get" Hibernate. The general idea is *working with the database rather
than against it*. Too often I have seen attempts to "abstract away" the database using Hibernate (or
other ORMs), which is counterproductive, leading to non-performant, brittle, hard to maintain code. In
such code bases it is extremely hard to predict which SQL statements are generated by Hibernate (without
the help of Hibernate logging).

That said, Hibernate/JPA *entities* are quite poor *data transfer objects* that are being passed across
application layers. Their mutability and use of proxy objects is a strength within an open
JPA `EntityManager` (or Hibernate `Session`), but a liability when passing around "data objects"
through the application (from service layer to web layer, for example).

A successful strategy for using Hibernate could therefore be as follows:
* Within an open JPA `EntityManager`, use Hibernate to work *with the database* as much as possible
  * See good resources on effective use of Hibernate in order to be successful
* Outside the `EntityManager`/`Session`, pass around data as *deeply immutable Java record class instances*
  * See for example the book *Effective Java, 3rd Edition*, by Joshua Bloch, on *minimizing mutability*

The underlying paradigms involved are quite different:
* Within an open `EntityManager`: JPA entities as old-school mutable JavaBeans, using `null` everywhere
* Outside the `EntityManager`: immutable Java records, avoiding `null`, using (type-safe) `Optional` instead

Sometimes Hibernate is not a good fit, and directly working with SQL in a type-safe manner is preferable.
This is where [jOOQ](https://www.jooq.org/) shines. Combining jOOQ and Hibernate in the same code base
is quite normal, and works very well with technology-agnostic service interfaces working with immutable
data objects.

In this and other projects I explore these ideas. Combining seemingly conflicting ideas in the same
code base can be made bearable by the use of clear Javadoc comments in `package-info.java` source files.

## Using Hibernate (as JPA implementation) in tandem with the database

Some general advice on using Hibernate ORM, from the horse's mouth, can be found
[here](https://docs.hibernate.org/orm/7.1/introduction/html_single/#advice). The most common problem
with Hibernate is causing the execution of too many (generated) SQL queries, in particular the
*N + 1 selects* problem
(see [Association Fetching](https://docs.hibernate.org/orm/7.1/introduction/html_single/#association-fetching)).

This is easy to avoid when writing SQL ourselves, which is what we do when using *low-level JDBC* or
the Spring `JdbcTemplate` (which at least takes JDBC resource and transaction management out of our hands).
With Hibernate we have to know not just SQL, but also the abstraction that Hibernate offers.

As said before, we should work in tandem with the database. When writing SQL ourselves, we are used
to *joining tables on an ad-hoc basis*. We could mimic this idea when using Hibernate too.
That is, consider *JPA entities* as *Java representations of database table rows*, choosing *lazy
fetching* for all *associations*. Per JPQL query, an `EntityGraph` or `FETCH JOIN`'s could be used on
an *ad-hoc* basis, to make explicit which associations should be fetched.

The [Tutorials by Thorben Janssen](https://thorben-janssen.com/tutorials/) site can to a large extent be considered
a one-stop shop for "all things Hibernate/JPA". It comes with great advice about how to use Hibernate
effectively. For example, the advice about using lazy fetching can be found
[here](https://thorben-janssen.com/hibernate-performance-tuning/). In particular:
[Use Lazy Fetching](https://thorben-janssen.com/hibernate-performance-tuning/#avoid-unnecessary-queries--choose-the-right-fetchtype)
and [Use Query-specific Fetching](https://thorben-janssen.com/hibernate-performance-tuning/#avoid-unnecessary-queries--use-queryspecific-fetching).

So far I haven't really seen that advice being followed. Hence, my misconception that Hibernate is
intrinsically very hard to use well.

Also see the other Hibernate performance advice in
[here](https://thorben-janssen.com/hibernate-performance-tuning/). More on Hibernate performance can be
found in [Hibernate Performance](https://thorben-janssen.com/tutorials/#performance).

Sometimes it can be a bit hard to choose between alternative solutions to a problem if these alternatives
each have some downsides. For example,
[Many-to-Many Association Collections](https://thorben-janssen.com/5-common-hibernate-mistakes-that-cause-dozens-of-unexpected-queries/#4-modeling-manytomany-associations-as-a-list)
suggest we should use `java.util.Set` rather than `java.util.List` for many-to-many associations. Yet that
requires high quality `equals` and `hashCode` methods to be implemented for the association element type,
although that is not mentioned in this advice. Defining stable `equals`/`hashCode` for mutable JPA entities
is a challenge in itself. Basing it on the technical primary key is a bad idea if the primary key is
generated by the database. If we don't additionally have a good "natural key" to base `equals` on it
becomes quite hard to override `equals`/`hashCode` without violating their "contracts" as defined in
the Javadoc documentation of class `java.lang.Object`. If needed, we can split a JPQL query into 2
queries, combining the results afterward. This can also be a valid choice when faced with Hibernate's
[`MultipleBagFetchException`](https://thorben-janssen.com/fix-multiplebagfetchexception-hibernate/).

As mentioned [here](https://docs.hibernate.org/orm/7.1/introduction/html_single/#advice), keep things
simple, and take control over generated SQL. Partly repeating myself, this means:
* Use *lazy fetching* for all entity associations
* Use *query-specific fetching*, thus also avoiding Hibernate's [`LazyInitializationException`](https://thorben-janssen.com/lazyinitializationexception/)
* Avoid overusing *cascading* of operations

In a large code base maintained by multiple developers we can stimulate the use of these best practices
as follows:
* Clearly documenting these *design considerations* in `package-info.java` source files
* At the same time, *validating* the code base against these best practices with [ArchUnit](https://www.archunit.org/)

Finally, *Java is statically typed*, which makes Java feel "a bit heavy" to some, but at least makes
refactoring a Java code base feasible. With Hibernate we easily lose some of that type-safety, unless
we use its [Static Metamodel Generator](https://docs.hibernate.org/orm/7.2/userguide/html_single/#tooling-modelgen)
as well as [Criteria Queries](https://docs.hibernate.org/orm/7.2/userguide/html_single/#criteria)
rather than plain [HQL/JPQL](https://docs.hibernate.org/orm/7.2/userguide/html_single/#hql). In my view,
this helps find many small programming errors as early as possible, which is a good thing.

## Using service interfaces, and passing data around as immutable Java records


## Using jOOQ where JPA/Hibernate offers less value

